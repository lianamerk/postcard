---
interface Props {
  postcard: {
    id: string;
    front: string;
    back: string;
    name: string;
  };
  category: string;
  index: number;
  total: number;
  allPostcards: Array<{
    id: string;
    front: string;
    back: string;
    name: string;
  }>;
}

const { postcard, category, index, total } = Astro.props;
// Include base path for images (needed for both dev and production with base path)
const base = import.meta.env.BASE_URL;
// Ensure proper path joining (BASE_URL ends with /, so we need to handle it)
const basePath = base.endsWith('/') ? base.slice(0, -1) : base;
const frontPath = `${basePath}/${category}/${postcard.front}`;
const backPath = `${basePath}/${category}/${postcard.back}`;

// For Hold-to-light: base name shows on page, _002 on hover, _001 in lightbox
const isHoldToLight = category === 'Hold-to-light' || category === 'Hold_to_light';
let hoverBackPath = backPath; // Default to _001
let lightboxBackPath = backPath; // Default to _001

if (isHoldToLight) {
  // Front is base name (no suffix), back is _001
  // For hover, construct _002 path from front image name
  const baseName = postcard.front.replace(/\.(png|jpg|jpeg|webp)$/i, '');
  const ext = postcard.front.match(/\.(png|jpg|jpeg|webp)$/i)?.[1] || 'png';
  // Hover shows _002 (shine-through)
  hoverBackPath = `${basePath}/${category}/${baseName}_002.${ext}`;
  // Lightbox shows base name (front) + _001 (back)
  lightboxBackPath = backPath; // This should already be _001
}
---

<div 
  class="postcard-container" 
  data-postcard-id={postcard.id}
  data-index={index}
  data-total={total}
  data-category={category}
  data-no-flip={category === 'Hold-to-light' || category === 'Hold_to_light' ? 'true' : 'false'}
>
  <div class="postcard-flip">
    <div class="postcard-front">
      <div class="image-placeholder"></div>
      <img 
        src={frontPath} 
        alt={`${postcard.name} - Front`}
        loading="lazy"
        class="front-image"
        decoding="async"
      />
    </div>
    <div class="postcard-back">
      <div class="image-placeholder"></div>
      <img 
        src={isHoldToLight ? hoverBackPath : backPath} 
        data-lightbox-back={lightboxBackPath}
        alt={`${postcard.name} - Back`}
        loading="lazy"
        class="back-image"
        decoding="async"
        onerror={isHoldToLight ? `this.src='${backPath}';this.onerror=null;` : undefined}
      />
    </div>
  </div>
</div>

<script>
  function initPostcardClick() {
    const containers = document.querySelectorAll('.postcard-container');
    
    // Sync back image height with front image for each postcard
    containers.forEach(container => {
      const frontImg = container.querySelector('.front-image') as HTMLImageElement | null;
      const backDiv = container.querySelector('.postcard-back') as HTMLElement | null;
      const backImg = container.querySelector('.back-image') as HTMLImageElement | null;
      
      // Check if this is a no-flip postcard (Hold-to-light)
      const noFlip = container.getAttribute('data-no-flip') === 'true';
      
      // For no-flip postcards, ensure back image is positioned correctly
      if (noFlip && backDiv) {
        backDiv.style.position = 'absolute';
        backDiv.style.top = '0';
        backDiv.style.left = '0';
      }
      
      if (frontImg && backDiv && backImg) {
        // Handle image loading with fade-in effect
        const handleImageLoad = (img: HTMLImageElement) => {
          img.classList.add('loaded');
          // Hide placeholder when image loads
          const placeholder = img.parentElement?.querySelector('.image-placeholder') as HTMLElement;
          if (placeholder) {
            placeholder.style.display = 'none';
          }
        };

        // Check if already loaded
        if (frontImg.complete && frontImg.naturalHeight > 0) {
          handleImageLoad(frontImg);
        } else {
          frontImg.addEventListener('load', () => handleImageLoad(frontImg));
        }

        if (backImg.complete && backImg.naturalHeight > 0) {
          handleImageLoad(backImg);
        } else {
          backImg.addEventListener('load', () => handleImageLoad(backImg));
        }

        // Sync back container height to match front image when loaded
        // This ensures the flip animation works regardless of image orientation
        const syncHeights = () => {
          if (frontImg.complete && frontImg.naturalHeight > 0 && backImg.complete && backImg.naturalHeight > 0) {
            // Use the actual rendered height of the front image
            const frontHeight = frontImg.offsetHeight || frontImg.clientHeight;
            const frontWidth = frontImg.offsetWidth || frontImg.clientWidth;
            
            if (frontHeight > 0 && frontWidth > 0) {
              // Calculate the back image's natural height at the front's width
              const backAspectRatio = backImg.naturalWidth / backImg.naturalHeight;
              const backHeightAtFrontWidth = frontWidth / backAspectRatio;
              
              // Set back container to match whichever is taller (front or back at front width)
              const containerHeight = Math.max(frontHeight, backHeightAtFrontWidth);
              backDiv.style.height = containerHeight + 'px';
              
              // Let the back image scale naturally like the front
              backImg.style.width = '100%';
              backImg.style.height = 'auto';
            }
          }
        };
        
        // Wait for both images to load
        const trySync = () => {
          if (frontImg.complete && backImg.complete) {
            syncHeights();
          }
        };
        
        // Try to sync immediately if both images are already loaded
        if (frontImg.complete && backImg.complete && frontImg.naturalHeight > 0 && backImg.naturalHeight > 0) {
          // Small delay to ensure layout is complete
          setTimeout(syncHeights, 10);
        } else {
          frontImg.addEventListener('load', trySync);
          backImg.addEventListener('load', trySync);
        }
        
        // Also sync on window resize
        let resizeTimeout: ReturnType<typeof setTimeout>;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(syncHeights, 100);
        });
      }
      
      // Click handler for lightbox
      container.addEventListener('click', () => {
        const frontImgEl = container.querySelector('.front-image') as HTMLImageElement | null;
        const backImgEl = container.querySelector('.back-image') as HTMLImageElement | null;
        if (!frontImgEl || !backImgEl) return;
        
        // Get postcard data from data attributes
        const currentIndex = parseInt(container.getAttribute('data-index') || '0');
        const totalPostcards = parseInt(container.getAttribute('data-total') || '1');
        const categoryName = container.getAttribute('data-category') || '';
        
        // Get paths from img src (already includes base path)
        const frontPath = frontImgEl.getAttribute('src') || '';
        // For Hold-to-light, use data-lightbox-back if available (the _001 back), otherwise use src
        const backPath = backImgEl.getAttribute('data-lightbox-back') || backImgEl.getAttribute('src') || '';
        const name = frontImgEl.getAttribute('alt')?.replace(' - Front', '') || '';
        
        if (!frontPath || !backPath) return;
        
        // Get or create lightbox
        let lightbox = document.getElementById('lightbox');
        if (!lightbox) {
          // Create lightbox dynamically
          lightbox = document.createElement('div');
          lightbox.id = 'lightbox';
          lightbox.className = 'lightbox';
          lightbox.innerHTML = `
            <div class="lightbox-content">
              <button class="lightbox-close" id="lightbox-close" aria-label="Close">×</button>
              <button class="lightbox-nav lightbox-prev" id="lightbox-prev" ${currentIndex === 0 ? 'style="display:none"' : ''}>&#8249;</button>
              <button class="lightbox-nav lightbox-next" id="lightbox-next" ${currentIndex >= totalPostcards - 1 ? 'style="display:none"' : ''}>&#8250;</button>
              <div class="lightbox-images">
                <div class="lightbox-image-container">
                  <img src="${frontPath}" alt="${name} - Front" class="lightbox-image" id="lightbox-front" />
                </div>
                <div class="lightbox-image-container">
                  <img src="${backPath}" alt="${name} - Back" class="lightbox-image" id="lightbox-back" />
                </div>
              </div>
            </div>
          `;
          document.body.appendChild(lightbox);
          
          // Store navigation data
          const lb = lightbox as HTMLElement & { currentIndex?: number; totalPostcards?: number; categoryName?: string };
          lb.currentIndex = currentIndex;
          lb.totalPostcards = totalPostcards;
          lb.categoryName = categoryName;
          
          // Add event listeners
          const closeBtn = lightbox.querySelector('#lightbox-close') as HTMLElement | null;
          const prevBtn = lightbox.querySelector('#lightbox-prev') as HTMLElement | null;
          const nextBtn = lightbox.querySelector('#lightbox-next') as HTMLElement | null;
          
          // Close button handler
          if (closeBtn) {
            closeBtn.setAttribute('data-listener-attached', 'true');
            closeBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              if (lightbox) {
                lightbox.classList.remove('active');
                document.body.style.overflow = '';
              }
            });
          }
          
          // Navigation function
          const navigatePostcard = (direction: number) => {
            const lb = document.getElementById('lightbox') as HTMLElement & { currentIndex?: number; totalPostcards?: number; categoryName?: string };
            if (!lb || lb.currentIndex === undefined || lb.totalPostcards === undefined) return;
            
            const newIndex = lb.currentIndex + direction;
            if (newIndex < 0 || newIndex >= lb.totalPostcards) return;
            
            // Find the postcard container for the new index
            const allContainers = document.querySelectorAll(`.postcard-container[data-category="${lb.categoryName}"]`);
            const targetContainer = allContainers[newIndex] as HTMLElement;
            if (!targetContainer) return;
            
            const frontImg = targetContainer.querySelector('.front-image') as HTMLImageElement | null;
            const backImg = targetContainer.querySelector('.back-image') as HTMLImageElement | null;
            if (!frontImg || !backImg) return;
            
            const newFrontPath = frontImg.getAttribute('src') || '';
            // For Hold-to-light, use data-lightbox-back if available (the _001 back), otherwise use src
            const newBackPath = backImg.getAttribute('data-lightbox-back') || backImg.getAttribute('src') || '';
            
            // Update lightbox images
            const lightboxFront = lb.querySelector('#lightbox-front') as HTMLImageElement | null;
            const lightboxBack = lb.querySelector('#lightbox-back') as HTMLImageElement | null;
            if (lightboxFront) lightboxFront.src = newFrontPath;
            if (lightboxBack) lightboxBack.src = newBackPath;
            
            // Update index
            lb.currentIndex = newIndex;
            
            // Update navigation buttons
            if (prevBtn) prevBtn.style.display = newIndex === 0 ? 'none' : 'flex';
            if (nextBtn) nextBtn.style.display = newIndex >= lb.totalPostcards - 1 ? 'none' : 'flex';
          };
          
          if (prevBtn) {
            prevBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              navigatePostcard(-1);
            });
          }
          
          if (nextBtn) {
            nextBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              navigatePostcard(1);
            });
          }
          
          lightbox.addEventListener('click', (e) => {
            if (e.target === lightbox && lightbox) {
              lightbox.classList.remove('active');
              document.body.style.overflow = '';
            }
          });
          
          document.addEventListener('keydown', (e) => {
            const lb = document.getElementById('lightbox') as HTMLElement & { currentIndex?: number; totalPostcards?: number; categoryName?: string };
            if (!lb || !lb.classList.contains('active')) return;
            
            if (e.key === 'Escape') {
              lb.classList.remove('active');
              document.body.style.overflow = '';
            } else if (e.key === 'ArrowLeft') {
              e.preventDefault();
              navigatePostcard(-1);
            } else if (e.key === 'ArrowRight') {
              e.preventDefault();
              navigatePostcard(1);
            }
          });
        } else {
          // Update existing lightbox
          const lb = lightbox as HTMLElement & { currentIndex?: number; totalPostcards?: number; categoryName?: string };
          lb.currentIndex = currentIndex;
          lb.totalPostcards = totalPostcards;
          lb.categoryName = categoryName;
          
          // Ensure close button exists
          let closeBtn = lightbox.querySelector('#lightbox-close') as HTMLElement | null;
          if (!closeBtn) {
            const lightboxContent = lightbox.querySelector('.lightbox-content');
            if (lightboxContent) {
              closeBtn = document.createElement('button');
              closeBtn.id = 'lightbox-close';
              closeBtn.className = 'lightbox-close';
              closeBtn.setAttribute('aria-label', 'Close');
              closeBtn.textContent = '×';
              lightboxContent.insertBefore(closeBtn, lightboxContent.firstChild);
            }
          }
          
          // Reattach close button handler if needed
          if (closeBtn && !closeBtn.hasAttribute('data-listener-attached')) {
            closeBtn.setAttribute('data-listener-attached', 'true');
            closeBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              if (lightbox) {
                lightbox.classList.remove('active');
                document.body.style.overflow = '';
              }
            });
          }
          
          const frontImg = lightbox.querySelector('#lightbox-front') as HTMLImageElement | null;
          const backImg = lightbox.querySelector('#lightbox-back') as HTMLImageElement | null;
          const prevBtn = lightbox.querySelector('#lightbox-prev') as HTMLElement | null;
          const nextBtn = lightbox.querySelector('#lightbox-next') as HTMLElement | null;
          
          // Get the correct back path (for Hold-to-light, use data-lightbox-back)
          const backImgEl = container.querySelector('.back-image') as HTMLImageElement | null;
          const correctBackPath = backImgEl?.getAttribute('data-lightbox-back') || backPath;
          
          if (frontImg) frontImg.src = frontPath;
          if (backImg) backImg.src = correctBackPath;
          if (prevBtn) prevBtn.style.display = currentIndex === 0 ? 'none' : 'flex';
          if (nextBtn) nextBtn.style.display = currentIndex >= totalPostcards - 1 ? 'none' : 'flex';
        }
        
        // Show lightbox
        if (lightbox) {
          lightbox.classList.add('active');
          document.body.style.overflow = 'hidden';
          
          // Add idle detection for arrow fading
          let idleTimeout: ReturnType<typeof setTimeout>;
          const resetIdle = () => {
            if (lightbox) {
              lightbox.classList.remove('idle');
              clearTimeout(idleTimeout);
              idleTimeout = setTimeout(() => {
                if (lightbox) {
                  lightbox.classList.add('idle');
                }
              }, 200); // Fade after 0.2 seconds of no movement
            }
          };
          
          lightbox.addEventListener('mousemove', resetIdle);
          lightbox.addEventListener('mouseenter', () => {
            if (lightbox) lightbox.classList.remove('idle');
          });
          resetIdle(); // Start the timer
        }
      });
    });
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPostcardClick);
  } else {
    initPostcardClick();
  }
</script>

<style>
  .postcard-container {
    width: 100%;
    perspective: 1000px;
    cursor: pointer;
    opacity: 0; /* Start hidden, masonry will show */
    position: relative;
    z-index: 1;
  }
  
  .postcard-container:hover {
    z-index: 10; /* Bring hovered card to front */
  }

  .postcard-flip {
    position: relative;
    width: 100%;
    transform-style: preserve-3d;
    transition: transform 0.6s;
  }

  html[data-hover-enabled="true"] .postcard-container:not([data-no-flip="true"]):hover .postcard-flip {
    transform: rotateY(180deg);
  }

  .postcard-front {
    position: relative;
    width: 100%;
    backface-visibility: hidden;
    border-radius: 4px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.3s, opacity 0.2s;
  }
  
  .postcard-back {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    backface-visibility: hidden;
    border-radius: 4px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.3s, opacity 0.2s;
    transform: rotateY(180deg);
  }

  /* For no-flip postcards (Hold-to-light): no rotation, just opacity swap */
  .postcard-container[data-no-flip="true"] .postcard-back {
    transform: none;
    backface-visibility: visible;
    opacity: 0;
  }

  html[data-hover-enabled="true"] .postcard-container[data-no-flip="true"]:hover .postcard-front {
    opacity: 0;
  }

  html[data-hover-enabled="true"] .postcard-container[data-no-flip="true"]:hover .postcard-back {
    opacity: 1;
  }

  .postcard-container:hover .postcard-front,
  .postcard-container:hover .postcard-back {
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
  }

  .postcard-front img {
    width: 100%;
    height: auto;
    display: block;
    /* Respect EXIF orientation data - this tells browser to auto-rotate based on EXIF */
    image-orientation: from-image;
  }
  
  .postcard-back img {
    width: 100%;
    height: auto;
    display: block;
    /* Respect EXIF orientation */
    image-orientation: from-image;
  }
</style>
