---
interface Props {
  postcard: {
    id: string;
    front: string;
    back: string;
    name: string;
  };
  category: string;
  index: number;
  total: number;
  allPostcards: Array<{
    id: string;
    front: string;
    back: string;
    name: string;
  }>;
}

const { postcard, category, index, total } = Astro.props;
// Include base path for images (needed for both dev and production with base path)
const base = import.meta.env.BASE_URL;
// Ensure proper path joining (BASE_URL ends with /, so we need to handle it)
const basePath = base.endsWith('/') ? base.slice(0, -1) : base;

// Helper function to generate WebP and optimized paths
// Falls back to original if optimized versions don't exist
function getImagePaths(imageName: string, category: string) {
  const baseName = imageName.replace(/\.(png|jpg|jpeg|webp)$/i, '');
  const ext = imageName.match(/\.(png|jpg|jpeg|webp)$/i)?.[1] || 'png';
  const originalPath = `${basePath}/${category}/${imageName}`;
  const webpPath = `${basePath}/${category}/webp/${baseName}.webp`;
  const optimizedPath = `${basePath}/${category}/optimized/${imageName}`;
  // Use original as fallback if optimized doesn't exist
  return { originalPath, webpPath, optimizedPath, fallbackPath: originalPath };
}

const frontPaths = getImagePaths(postcard.front, category);
const backPaths = getImagePaths(postcard.back, category);

// For Hold-to-light: base name shows on page, _002 on hover, _001 in lightbox
const isHoldToLight = category === 'Hold-to-light' || category === 'Hold_to_light';
let hoverBackPaths = backPaths; // Default to _001
let lightboxBackPaths = backPaths; // Default to _001

if (isHoldToLight) {
  // Front is base name (no suffix), back is _001
  // For hover, construct _002 path from front image name
  const baseName = postcard.front.replace(/\.(png|jpg|jpeg|webp)$/i, '');
  const ext = postcard.front.match(/\.(png|jpg|jpeg|webp)$/i)?.[1] || 'png';
  const hoverImageName = `${baseName}_002.${ext}`;
  hoverBackPaths = getImagePaths(hoverImageName, category);
  // Lightbox shows base name (front) + _001 (back)
  lightboxBackPaths = backPaths; // This should already be _001
}
---

<div 
  class="postcard-container" 
  data-postcard-id={postcard.id}
  data-index={index}
  data-total={total}
  data-category={category}
  data-no-flip={category === 'Hold-to-light' || category === 'Hold_to_light' ? 'true' : 'false'}
>
  <div class="postcard-flip">
    <div class="postcard-front">
      <div class="image-placeholder"></div>
      <picture>
        <source srcset={frontPaths.webpPath} type="image/webp" />
        <source srcset={frontPaths.optimizedPath} type={`image/${frontPaths.optimizedPath.match(/\.(png|jpg|jpeg)$/i)?.[1] || 'png'}`} />
        <img 
          src={frontPaths.originalPath} 
          alt={`${postcard.name} - Front`}
          loading="lazy"
          class="front-image"
          decoding="async"
        />
      </picture>
    </div>
    <div class="postcard-back">
      <div class="image-placeholder"></div>
      <picture>
        <source srcset={isHoldToLight ? hoverBackPaths.webpPath : backPaths.webpPath} type="image/webp" />
        <source srcset={isHoldToLight ? hoverBackPaths.optimizedPath : backPaths.optimizedPath} type={`image/${(isHoldToLight ? hoverBackPaths.optimizedPath : backPaths.optimizedPath).match(/\.(png|jpg|jpeg)$/i)?.[1] || 'png'}`} />
        <img 
          src={isHoldToLight ? hoverBackPaths.originalPath : backPaths.originalPath} 
          data-lightbox-back={lightboxBackPaths.originalPath}
          data-lightbox-back-webp={lightboxBackPaths.webpPath}
          data-lightbox-back-optimized={lightboxBackPaths.optimizedPath}
          alt={`${postcard.name} - Back`}
          loading="lazy"
          class="back-image"
          decoding="async"
          onerror={isHoldToLight ? `this.src='${backPaths.originalPath}';this.onerror=null;` : undefined}
        />
      </picture>
    </div>
  </div>
</div>

<script>
  function initPostcardClick() {
    const containers = document.querySelectorAll('.postcard-container');
    
    // Sync back image height with front image for each postcard
    containers.forEach(container => {
      const frontImg = container.querySelector('.front-image') as HTMLImageElement | null;
      const backDiv = container.querySelector('.postcard-back') as HTMLElement | null;
      const backImg = container.querySelector('.back-image') as HTMLImageElement | null;
      
      // Check if this is a no-flip postcard (Hold-to-light)
      const noFlip = container.getAttribute('data-no-flip') === 'true';
      
      // For no-flip postcards, ensure back image is positioned correctly
      if (noFlip && backDiv) {
        backDiv.style.position = 'absolute';
        backDiv.style.top = '0';
        backDiv.style.left = '0';
      }
      
      if (frontImg && backDiv && backImg) {
        // Handle image loading with fade-in effect
        const handleImageLoad = (img: HTMLImageElement) => {
          img.classList.add('loaded');
          // Hide placeholder when image loads
          const placeholder = img.parentElement?.querySelector('.image-placeholder') as HTMLElement;
          if (placeholder) {
            placeholder.style.display = 'none';
          }
        };

        // Check if already loaded
        if (frontImg.complete && frontImg.naturalHeight > 0) {
          handleImageLoad(frontImg);
        } else {
          frontImg.addEventListener('load', () => handleImageLoad(frontImg));
        }

        if (backImg.complete && backImg.naturalHeight > 0) {
          handleImageLoad(backImg);
        } else {
          backImg.addEventListener('load', () => handleImageLoad(backImg));
        }

        // Sync back container height to match front image when loaded
        // This ensures the flip animation works regardless of image orientation
        const syncHeights = () => {
          if (frontImg.complete && frontImg.naturalHeight > 0 && backImg.complete && backImg.naturalHeight > 0) {
            // Use the actual rendered height of the front image
            const frontHeight = frontImg.offsetHeight || frontImg.clientHeight;
            const frontWidth = frontImg.offsetWidth || frontImg.clientWidth;
            
            if (frontHeight > 0 && frontWidth > 0) {
              // Calculate the back image's natural height at the front's width
              const backAspectRatio = backImg.naturalWidth / backImg.naturalHeight;
              const backHeightAtFrontWidth = frontWidth / backAspectRatio;
              
              // Set back container to match whichever is taller (front or back at front width)
              const containerHeight = Math.max(frontHeight, backHeightAtFrontWidth);
              backDiv.style.height = containerHeight + 'px';
              
              // Let the back image scale naturally like the front
              backImg.style.width = '100%';
              backImg.style.height = 'auto';
            }
          }
        };
        
        // Wait for both images to load
        const trySync = () => {
          if (frontImg.complete && backImg.complete) {
            syncHeights();
          }
        };
        
        // Try to sync immediately if both images are already loaded
        if (frontImg.complete && backImg.complete && frontImg.naturalHeight > 0 && backImg.naturalHeight > 0) {
          // Small delay to ensure layout is complete
          setTimeout(syncHeights, 10);
        } else {
          frontImg.addEventListener('load', trySync);
          backImg.addEventListener('load', trySync);
        }
        
        // Also sync on window resize
        let resizeTimeout: ReturnType<typeof setTimeout>;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(syncHeights, 100);
        });
      }
      
      // Helper function to get WebP and fallback paths from picture element
      function getImagePathsFromPicture(img: HTMLImageElement | null): { webp: string; fallback: string; type: string } | null {
        if (!img) return null;
        const picture = img.closest('picture');
        if (!picture) {
          // Fallback: if no picture element, use img src
          const src = img.getAttribute('src') || '';
          return { webp: src, fallback: src, type: 'png' };
        }
        const webpSource = picture.querySelector('source[type="image/webp"]') as HTMLSourceElement;
        const fallbackSource = picture.querySelector('source:not([type="image/webp"])') as HTMLSourceElement;
        const webp = webpSource?.getAttribute('srcset') || img.getAttribute('src') || '';
        const fallback = fallbackSource?.getAttribute('srcset') || img.getAttribute('src') || '';
        const type = fallback.match(/\.(png|jpg|jpeg)$/i)?.[1] || 'png';
        return { webp, fallback, type };
      }
      
      // Click handler for lightbox
      container.addEventListener('click', () => {
        const frontImgEl = container.querySelector('.front-image') as HTMLImageElement | null;
        const backImgEl = container.querySelector('.back-image') as HTMLImageElement | null;
        if (!frontImgEl || !backImgEl) return;
        
        // Get postcard data from data attributes
        const currentIndex = parseInt(container.getAttribute('data-index') || '0');
        const totalPostcards = parseInt(container.getAttribute('data-total') || '1');
        const categoryName = container.getAttribute('data-category') || '';
        
        // Get paths from picture element or img src
        const frontPaths = getImagePathsFromPicture(frontImgEl);
        // For Hold-to-light, use data-lightbox-back if available (the _001 back)
        const backImgForLightbox = backImgEl.getAttribute('data-lightbox-back') 
          ? (() => {
              const webpPath = backImgEl.getAttribute('data-lightbox-back-webp') || '';
              const optimizedPath = backImgEl.getAttribute('data-lightbox-back-optimized') || '';
              const fallbackPath = backImgEl.getAttribute('data-lightbox-back') || '';
              return { webp: webpPath, optimized: optimizedPath, fallback: fallbackPath, type: fallbackPath.match(/\.(png|jpg|jpeg)$/i)?.[1] || 'png' };
            })()
          : getImagePathsFromPicture(backImgEl);
        
        if (!frontPaths || !backImgForLightbox) return;
        
        const name = frontImgEl.getAttribute('alt')?.replace(' - Front', '') || '';
        
        // Get or create lightbox
        let lightbox = document.getElementById('lightbox');
        if (!lightbox) {
          // Create lightbox dynamically
          lightbox = document.createElement('div');
          lightbox.id = 'lightbox';
          lightbox.className = 'lightbox';
          lightbox.innerHTML = `
            <div class="lightbox-content">
              <button class="lightbox-close" id="lightbox-close" aria-label="Close">×</button>
              <button class="lightbox-nav lightbox-prev" id="lightbox-prev" ${currentIndex === 0 ? 'style="display:none"' : ''}>&#8249;</button>
              <button class="lightbox-nav lightbox-next" id="lightbox-next" ${currentIndex >= totalPostcards - 1 ? 'style="display:none"' : ''}>&#8250;</button>
              <div class="lightbox-images">
                <div class="lightbox-image-container">
                  <picture>
                    <source srcset="${frontPaths.webp}" type="image/webp" />
                    <source srcset="${frontPaths.fallback}" type="image/${frontPaths.type}" />
                    <img src="${frontPaths.fallback}" alt="${name} - Front" class="lightbox-image" id="lightbox-front" />
                  </picture>
                </div>
                <div class="lightbox-image-container">
                  <picture>
                    <source srcset="${backImgForLightbox.webp}" type="image/webp" />
                    <source srcset="${backImgForLightbox.optimized || backImgForLightbox.fallback}" type="image/${backImgForLightbox.type}" />
                    <img src="${backImgForLightbox.fallback}" alt="${name} - Back" class="lightbox-image" id="lightbox-back" />
                  </picture>
                </div>
              </div>
            </div>
          `;
          document.body.appendChild(lightbox);
          
          // Store navigation data
          const lb = lightbox as HTMLElement & { currentIndex?: number; totalPostcards?: number; categoryName?: string };
          lb.currentIndex = currentIndex;
          lb.totalPostcards = totalPostcards;
          lb.categoryName = categoryName;
          
          // Add event listeners
          const closeBtn = lightbox.querySelector('#lightbox-close') as HTMLElement | null;
          const prevBtn = lightbox.querySelector('#lightbox-prev') as HTMLElement | null;
          const nextBtn = lightbox.querySelector('#lightbox-next') as HTMLElement | null;
          
          // Close button handler
          if (closeBtn) {
            closeBtn.setAttribute('data-listener-attached', 'true');
            closeBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              if (lightbox) {
                lightbox.classList.remove('active');
                document.body.style.overflow = '';
              }
            });
          }
          
          // Navigation function
          const navigatePostcard = (direction: number) => {
            const lb = document.getElementById('lightbox') as HTMLElement & { currentIndex?: number; totalPostcards?: number; categoryName?: string };
            if (!lb || lb.currentIndex === undefined || lb.totalPostcards === undefined) return;
            
            const newIndex = lb.currentIndex + direction;
            if (newIndex < 0 || newIndex >= lb.totalPostcards) return;
            
            // Find the postcard container for the new index
            const allContainers = document.querySelectorAll(`.postcard-container[data-category="${lb.categoryName}"]`);
            const targetContainer = allContainers[newIndex] as HTMLElement;
            if (!targetContainer) return;
            
            const frontImg = targetContainer.querySelector('.front-image') as HTMLImageElement | null;
            const backImg = targetContainer.querySelector('.back-image') as HTMLImageElement | null;
            if (!frontImg || !backImg) return;
            
            // Get paths from picture element or img src
            const newFrontPaths = getImagePathsFromPicture(frontImg);
            const newBackPaths = backImg.getAttribute('data-lightbox-back')
              ? (() => {
                  const webpPath = backImg.getAttribute('data-lightbox-back-webp') || '';
                  const optimizedPath = backImg.getAttribute('data-lightbox-back-optimized') || '';
                  const fallbackPath = backImg.getAttribute('data-lightbox-back') || '';
                  return { webp: webpPath, optimized: optimizedPath, fallback: fallbackPath, type: fallbackPath.match(/\.(png|jpg|jpeg)$/i)?.[1] || 'png' };
                })()
              : getImagePathsFromPicture(backImg);
            
            if (!newFrontPaths || !newBackPaths) return;
            
            // Update lightbox images (picture elements)
            const lightboxFrontPicture = lb.querySelector('#lightbox-front')?.closest('picture');
            const lightboxBackPicture = lb.querySelector('#lightbox-back')?.closest('picture');
            
            if (lightboxFrontPicture) {
              const webpSource = lightboxFrontPicture.querySelector('source[type="image/webp"]') as HTMLSourceElement;
              const fallbackSource = lightboxFrontPicture.querySelector('source:not([type="image/webp"])') as HTMLSourceElement;
              const img = lightboxFrontPicture.querySelector('img') as HTMLImageElement;
              if (webpSource) webpSource.srcset = newFrontPaths.webp;
              if (fallbackSource) fallbackSource.srcset = newFrontPaths.fallback;
              if (img) img.src = newFrontPaths.fallback;
            }
            
            if (lightboxBackPicture) {
              const webpSource = lightboxBackPicture.querySelector('source[type="image/webp"]') as HTMLSourceElement;
              const fallbackSource = lightboxBackPicture.querySelector('source:not([type="image/webp"])') as HTMLSourceElement;
              const img = lightboxBackPicture.querySelector('img') as HTMLImageElement;
              if (webpSource) webpSource.srcset = newBackPaths.webp;
              if (fallbackSource) fallbackSource.srcset = newBackPaths.optimized || newBackPaths.fallback;
              if (img) img.src = newBackPaths.fallback;
            }
            
            // Update index
            lb.currentIndex = newIndex;
            
            // Update navigation buttons
            if (prevBtn) prevBtn.style.display = newIndex === 0 ? 'none' : 'flex';
            if (nextBtn) nextBtn.style.display = newIndex >= lb.totalPostcards - 1 ? 'none' : 'flex';
          };
          
          if (prevBtn) {
            prevBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              navigatePostcard(-1);
            });
          }
          
          if (nextBtn) {
            nextBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              navigatePostcard(1);
            });
          }
          
          lightbox.addEventListener('click', (e) => {
            if (e.target === lightbox && lightbox) {
              lightbox.classList.remove('active');
              document.body.style.overflow = '';
            }
          });
          
          document.addEventListener('keydown', (e) => {
            const lb = document.getElementById('lightbox') as HTMLElement & { currentIndex?: number; totalPostcards?: number; categoryName?: string };
            if (!lb || !lb.classList.contains('active')) return;
            
            if (e.key === 'Escape') {
              lb.classList.remove('active');
              document.body.style.overflow = '';
            } else if (e.key === 'ArrowLeft') {
              e.preventDefault();
              navigatePostcard(-1);
            } else if (e.key === 'ArrowRight') {
              e.preventDefault();
              navigatePostcard(1);
            }
          });
        } else {
          // Update existing lightbox
          const lb = lightbox as HTMLElement & { currentIndex?: number; totalPostcards?: number; categoryName?: string };
          lb.currentIndex = currentIndex;
          lb.totalPostcards = totalPostcards;
          lb.categoryName = categoryName;
          
          // Ensure close button exists
          let closeBtn = lightbox.querySelector('#lightbox-close') as HTMLElement | null;
          if (!closeBtn) {
            const lightboxContent = lightbox.querySelector('.lightbox-content');
            if (lightboxContent) {
              closeBtn = document.createElement('button');
              closeBtn.id = 'lightbox-close';
              closeBtn.className = 'lightbox-close';
              closeBtn.setAttribute('aria-label', 'Close');
              closeBtn.textContent = '×';
              lightboxContent.insertBefore(closeBtn, lightboxContent.firstChild);
            }
          }
          
          // Reattach close button handler if needed
          if (closeBtn && !closeBtn.hasAttribute('data-listener-attached')) {
            closeBtn.setAttribute('data-listener-attached', 'true');
            closeBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              if (lightbox) {
                lightbox.classList.remove('active');
                document.body.style.overflow = '';
              }
            });
          }
          
          const frontImg = lightbox.querySelector('#lightbox-front') as HTMLImageElement | null;
          const backImg = lightbox.querySelector('#lightbox-back') as HTMLImageElement | null;
          const prevBtn = lightbox.querySelector('#lightbox-prev') as HTMLElement | null;
          const nextBtn = lightbox.querySelector('#lightbox-next') as HTMLElement | null;
          
          // Get the correct paths (for Hold-to-light, use data-lightbox-back)
          const frontImgEl = container.querySelector('.front-image') as HTMLImageElement | null;
          const backImgEl = container.querySelector('.back-image') as HTMLImageElement | null;
          const newFrontPaths = getImagePathsFromPicture(frontImgEl);
          const newBackPaths = backImgEl?.getAttribute('data-lightbox-back')
            ? (() => {
                const webpPath = backImgEl.getAttribute('data-lightbox-back-webp') || '';
                const optimizedPath = backImgEl.getAttribute('data-lightbox-back-optimized') || '';
                const fallbackPath = backImgEl.getAttribute('data-lightbox-back') || '';
                return { webp: webpPath, optimized: optimizedPath, fallback: fallbackPath, type: fallbackPath.match(/\.(png|jpg|jpeg)$/i)?.[1] || 'png' };
              })()
            : getImagePathsFromPicture(backImgEl);
          
          if (newFrontPaths && newBackPaths) {
            // Update front image
            const frontPicture = frontImg?.closest('picture');
            if (frontPicture) {
              const webpSource = frontPicture.querySelector('source[type="image/webp"]') as HTMLSourceElement;
              const fallbackSource = frontPicture.querySelector('source:not([type="image/webp"])') as HTMLSourceElement;
              if (webpSource) webpSource.srcset = newFrontPaths.webp;
              if (fallbackSource) fallbackSource.srcset = newFrontPaths.fallback;
              if (frontImg) frontImg.src = newFrontPaths.fallback;
            }
            
            // Update back image
            const backPicture = backImg?.closest('picture');
            if (backPicture) {
              const webpSource = backPicture.querySelector('source[type="image/webp"]') as HTMLSourceElement;
              const fallbackSource = backPicture.querySelector('source:not([type="image/webp"])') as HTMLSourceElement;
              if (webpSource) webpSource.srcset = newBackPaths.webp;
              if (fallbackSource) fallbackSource.srcset = newBackPaths.optimized || newBackPaths.fallback;
              if (backImg) backImg.src = newBackPaths.fallback;
            }
          }
          if (prevBtn) prevBtn.style.display = currentIndex === 0 ? 'none' : 'flex';
          if (nextBtn) nextBtn.style.display = currentIndex >= totalPostcards - 1 ? 'none' : 'flex';
        }
        
        // Show lightbox
        if (lightbox) {
          lightbox.classList.add('active');
          document.body.style.overflow = 'hidden';
          
          // Add idle detection for arrow fading
          let idleTimeout: ReturnType<typeof setTimeout>;
          const resetIdle = () => {
            if (lightbox) {
              lightbox.classList.remove('idle');
              clearTimeout(idleTimeout);
              idleTimeout = setTimeout(() => {
                if (lightbox) {
                  lightbox.classList.add('idle');
                }
              }, 200); // Fade after 0.2 seconds of no movement
            }
          };
          
          lightbox.addEventListener('mousemove', resetIdle);
          lightbox.addEventListener('mouseenter', () => {
            if (lightbox) lightbox.classList.remove('idle');
          });
          resetIdle(); // Start the timer
        }
      });
    });
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPostcardClick);
  } else {
    initPostcardClick();
  }
</script>

<style>
  .postcard-container {
    width: 100%;
    perspective: 1000px;
    cursor: pointer;
    opacity: 0; /* Start hidden, masonry will show */
    position: relative;
    z-index: 1;
  }
  
  .postcard-container:hover {
    z-index: 10; /* Bring hovered card to front */
  }

  .postcard-flip {
    position: relative;
    width: 100%;
    transform-style: preserve-3d;
    transition: transform 0.6s;
  }

  html[data-hover-enabled="true"] .postcard-container:not([data-no-flip="true"]):hover .postcard-flip {
    transform: rotateY(180deg);
  }

  .postcard-front {
    position: relative;
    width: 100%;
    backface-visibility: hidden;
    border-radius: 4px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.3s, opacity 0.2s;
  }
  
  .postcard-back {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    backface-visibility: hidden;
    border-radius: 4px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.3s, opacity 0.2s;
    transform: rotateY(180deg);
  }

  /* For no-flip postcards (Hold-to-light): no rotation, just opacity swap */
  .postcard-container[data-no-flip="true"] .postcard-back {
    transform: none;
    backface-visibility: visible;
    opacity: 0;
  }

  html[data-hover-enabled="true"] .postcard-container[data-no-flip="true"]:hover .postcard-front {
    opacity: 0;
  }

  html[data-hover-enabled="true"] .postcard-container[data-no-flip="true"]:hover .postcard-back {
    opacity: 1;
  }

  .postcard-container:hover .postcard-front,
  .postcard-container:hover .postcard-back {
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
  }

  .postcard-front img {
    width: 100%;
    height: auto;
    display: block;
    /* Images are already auto-rotated by sharp during optimization */
    /* No need for image-orientation since EXIF is removed after rotation */
  }
  
  .postcard-back img {
    width: 100%;
    height: auto;
    display: block;
    /* Images are already auto-rotated by sharp during optimization */
  }
</style>
